#!/usr/bin/env python
# Copyright (c) 2016 Tiger-Workshop Limited. All rights reserved.

import struct
import sys
import threading
import Queue
import json
import urllib
import tempfile
import uuid
import win32api
import win32com.client

try:
    import pdfkit
except ImportError:
    pdfkit = None

try:
    import Tkinter
    import tkMessageBox
except ImportError:
    Tkinter = None

# Debug Switch
Debug = True

# On Windows, the default I/O mode is O_TEXT. Set this to O_BINARY
# to avoid unwanted modifications of the input/output streams.
if sys.platform == "win32":
    import os, msvcrt
    msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)
    msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)

# Helper function that sends a message to the webapp.
def send_message(message):
   # Write message size.
    sys.stdout.write(struct.pack('I', len(message)))
    # Write the message itself.
    sys.stdout.write(message)
    sys.stdout.flush()

# Thread that reads messages from the webapp.
def read_thread_func(queue):
    message_number = 0
    while 1:
    # Read the message length (first 4 bytes).
        text_length_bytes = sys.stdin.read(4)

        if len(text_length_bytes) == 0:
            if queue:
                queue.put(None)
            sys.exit(0)

        try:
                # Unpack message length as 4 byte integer.
            text_length = struct.unpack('i', text_length_bytes)[0]

            # Read the text (JSON object) of the message.
            text = sys.stdin.read(text_length).decode('utf-8')
        except:
            text = ''
            print('Decode error: %s' % text)

        if queue:
            queue.put(text)
        else:
            # Procsss Input
            handler = MessageHandler(None)
            handler.handle(text)

class MessageHandler():
    def __init__(self, logger):
        self.logger = logger

    def log(self, message):
        if self.logger:
            self.logger.log(message)

    def response(self, message):
        self.log(">> %s" % message)
        send_message(message)

    def handle(self, message):

        self.log("<< %s" % message)
        data = json.loads(message)

        try:
            if not 'action' in data:
                raise ValueError('action required')

            if data['action'] == 'print':
                pdf_path = tempfile.gettempdir() + "/" + str(uuid.uuid4()) + ".pdf"

                if 'printer' in data and data['printer'] != False:
                    printer = data['printer']
                else:
                    printer = ''

                if 'url' in data:
                    self.log("Print from URL: %s" % data['url'])
                    urllib.urlretrieve(data['url'], pdf_path)
                    self.log("PDF Retrieved")
                elif 'html' in data:
                    self.log("Print from HTML: %s" % data['html'])
                    pdfkit.from_string(data['html'], pdf_path)
                    self.log("PDF Generated")
                else:
                    raise ValueError('url or html required')

                win32api.ShellExecute(0, "printto", pdf_path, printer, ".", 0)

                # OK Response
                self.response(json.dumps({'status': 0}))
            elif data['action'] == 'list_printer':
                strComputer = "."
                objWMIService = win32com.client.Dispatch("WbemScripting.SWbemLocator")
                objSWbemServices = objWMIService.ConnectServer(strComputer,"root\cimv2")
                colItems = objSWbemServices.ExecQuery("Select * from Win32_PrinterConfiguration")

                printers = []

                for objItem in colItems:
                    printers.append(objItem.Name)

                self.response(json.dumps({'status': 0, 'action': 'list', 'type': 'printer', 'items': printers}))
            else:
                raise ValueError('Unknown action')


        except Exception as e:
            # Error Response
            self.response(json.dumps({'status': 1, 'message': str(e)}))

if Tkinter:
    class NativeMessagingWindow(Tkinter.Frame):
        def __init__(self, queue):
            self.queue = queue

            Tkinter.Frame.__init__(self)
            self.pack()

            self.text = Tkinter.Text(self)
            self.text.grid(row=0, column=0, padx=10, pady=10, columnspan=2)
            self.text.config(state=Tkinter.DISABLED, height=20, width=50)

            self.messageContent = Tkinter.StringVar()
            self.sendEntry = Tkinter.Entry(self, textvariable=self.messageContent)
            self.sendEntry.grid(row=1, column=0, padx=10, pady=10)

            self.sendButton = Tkinter.Button(self, text="Send", command=self.onSend)
            self.sendButton.grid(row=1, column=1, padx=10, pady=10)

            self.after(100, self.processMessages)

        def processMessages(self):
            while not self.queue.empty():

                message = self.queue.get_nowait()
                if message == None:
                    self.quit()
                    return

                # Procsss Input
                handler = MessageHandler(self)
                handler.handle(message)

            self.after(100, self.processMessages)

        def onSend(self):
            text = '{"status": "' + self.messageContent.get() + '"}'
            self.log('>> %s' % text)
            try:
                send_message(text)
            except IOError:
                tkMessageBox.showinfo('Native Messaging Example',
                                      'Failed to send message.')
                sys.exit(1)

        def log(self, message):
            self.text.config(state=Tkinter.NORMAL)
            self.text.insert(Tkinter.END, message + "\n")
            self.text.config(state=Tkinter.DISABLED)


def Main():
    if not Tkinter or Debug == False:
        #send_message('Running in headless mode.')
        read_thread_func(None)
        sys.exit(0)

    queue = Queue.Queue()

    main_window = NativeMessagingWindow(queue)
    main_window.master.title('Chrome Hardware Bridge')

    thread = threading.Thread(target=read_thread_func, args=(queue,))
    thread.daemon = True
    thread.start()

    main_window.mainloop()

    sys.exit(0)


if __name__ == '__main__':
    Main()
